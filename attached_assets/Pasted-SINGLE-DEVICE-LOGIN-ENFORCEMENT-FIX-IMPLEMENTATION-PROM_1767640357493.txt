SINGLE-DEVICE LOGIN ENFORCEMENT â€“ FIX & IMPLEMENTATION PROMPT
âŒ CURRENT PROBLEM (CLEARLY STATED)

At present, the system uses force logout logic to control sessions, but:

Users can logout and login repeatedly

Users can switch devices unlimited times

Force logout does not truly bind login to one device

Multiple devices can still access the same account sequentially

This defeats the purpose of single-device login control.

ğŸ¯ REQUIRED BEHAVIOR (EXPECTED RESULT)

Only ONE device can be logged in at a time per user

Once logged in:

Login is locked to that device

User cannot login from another device

Login reset happens:

Automatically after 24 hours

OR manually by Admin

User cannot bypass restriction by:

Logging out

Clearing cookies

Re-logging from another device

No UI changes

No change to existing page flow

Fix must be backend + database enforced

ğŸ” WHY CURRENT FORCE LOGOUT FAILS

Current implementation:

Only clears session or token

Does NOT track device identity

Does NOT enforce backend validation

Trusts client-side logout

ğŸ‘‰ Result:
User logs out â†’ logs in again from any device â†’ works.

This is not device binding.

âœ… CORRECT SOLUTION (SERVER-SIDE DEVICE BINDING)
ğŸ”‘ Core Principle

Login permission must be decided by the server, not the client.

ğŸ—„ï¸ REQUIRED DATABASE CHANGES (MANDATORY)

Add these columns to the existing users (or login table):

ALTER TABLE users
ADD COLUMN device_id VARCHAR(255) NULL,
ADD COLUMN device_locked_until DATETIME NULL,
ADD COLUMN last_login_at DATETIME NULL;

Column Purpose
Column	Purpose
device_id	Unique identifier of the device
device_locked_until	When login restriction resets
last_login_at	Audit / tracking
ğŸ“± DEVICE IDENTIFICATION (IMPORTANT)

Generate one unique device ID per device using:

Android ID / WebView UUID

Or browser fingerprint (localStorage-based UUID)

This device_id must be:

Generated once

Stored locally

Sent with every login request

ğŸ” BACKEND LOGIN VALIDATION LOGIC (CRITICAL)
On Login Request:

Fetch user record

Check:

IF device_id IS NULL
â†’ First login â†’ bind device

ELSE IF device_id == incoming_device_id
â†’ Allow login

ELSE IF current_time > device_locked_until
â†’ Reset allowed â†’ update device_id

ELSE
â†’ BLOCK login (device limit reached)

â›” BLOCK RESPONSE (IMPORTANT)

If login is blocked, backend must return:

{
  "status": "blocked",
  "message": "This account is already logged in on another device. Try again after reset."
}


Frontend should only show message, no logic change.

â±ï¸ 24-HOUR AUTO RESET (SERVER-SIDE)

On successful login:

device_locked_until = now + 24 hours


This timer:

Must be checked on every login

Cannot be reset by user logout

ğŸ‘‘ ADMIN CONTROL (MANDATORY)

Admin panel must have:

Button: Reset Device Login

Action:

UPDATE users
SET device_id = NULL,
    device_locked_until = NULL
WHERE user_id = X;


Admin can also:

Change lock duration (e.g., 12h / 24h / 48h)

âŒ WHAT MUST NOT BE USED

âŒ Client-side only checks

âŒ Force logout alone

âŒ Session-only enforcement

âŒ Cookie-only logic

These are bypassable.

ğŸ§ª SECURITY TEST CASES (MUST PASS)

âœ” Login from Device A â†’ success
âœ” Login from Device B â†’ blocked
âœ” Logout from A â†’ still blocked on B
âœ” Clear browser data â†’ still blocked
âœ” After 24 hours â†’ B allowed
âœ” Admin reset â†’ B allowed immediately

ğŸ§  FINAL COPY-PASTE PROMPT (COMPLETE)

Implement strict single-device login enforcement.
The current force-logout system is insufficient as users can re-login from multiple devices.
Add server-side device binding using a unique device_id, enforce login validation in the backend, and store lock state in the database.
Only allow login if the incoming device matches the stored device or if the lock period has expired.
Automatically reset the device lock after 24 hours, with an option for admin to reset or modify the lock duration.
Do NOT change any UI, page layout, or existing business logic.
The fix must be backend-enforced and secure against logout, cookie clearing, or repeated login attempts.

ğŸ”’ FINAL NOTE (IMPORTANT)